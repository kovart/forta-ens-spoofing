import { HandleTransaction } from 'forta-agent';
import { TestTransactionEvent } from 'forta-agent-tools/lib/test';
import { createAddress } from 'forta-agent-tools';
import { ethers } from 'ethers';
import agent from './agent';
import { BotConfig, DataContainer } from './types';
import { Logger, LoggerLevel } from './logger';
import { createFinding } from './findings';

const { provideInitialize, provideHandleTransaction } = agent;

describe('ENS Spoofing bot', () => {
  describe('initialize()', () => {
    it('should initialize properly', async () => {
      const data: DataContainer = {} as any;
      const provider = new ethers.providers.JsonRpcProvider();
      const logger = new Logger();
      const config: BotConfig = {
        developerAbbreviation: 'AK',
        minASCIICharacters: 5,
        maxASCIIHomoglyphs: 4,
        ethRegistrarControllerAddress: createAddress('0x'),
      };

      const initialize = provideInitialize(data, config, provider, logger, true);

      await initialize();

      expect(data.isInitialized).toStrictEqual(true);
      expect(data.isDevelopment).toStrictEqual(true);
      expect(data.config).toStrictEqual(config);
      expect(data.logger).toStrictEqual(logger);
      expect(data.provider).toStrictEqual(provider);
    });
  });

  describe('handleTransaction()', () => {
    let mockData: DataContainer = {} as any;
    let mockProvider: jest.MockedObject<ethers.providers.StaticJsonRpcProvider>;
    let handleTransaction: HandleTransaction;

    const autoAddress = (
      (count) => () =>
        createAddress('0x' + count++)
    )(0);
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    const registerName = (name: string, account: string): void => {};
    const getENSRegisterTx = (names: { name: string; account: string }[]) => {
      return new TestTransactionEvent();
    };
    const generateName = (injectGlyphs: string[] = [], repeatCount = 1, length = 7) => {
      const symbols = 'abcdefghijklmnopqstvwxy';
      const glyphsStack = [];

      for (let i = 0; i < repeatCount; i++) {
        glyphsStack.push(...injectGlyphs);
      }

      if (glyphsStack.length > length)
        throw new Error(
          `The number of glyphs exceeds the desired name length. Glyphs: ${injectGlyphs.length}. Length: ${length}`,
        );

      let name = symbols.repeat(Math.max(1, Math.ceil(length / symbols.length))).slice(0, length);
      for (const index in glyphsStack) {
        const position = Math.floor(
          Number(index) * (length / glyphsStack.length) + length / glyphsStack.length / 2,
        );
        name = name.slice(0, position - 1) + glyphsStack[index] + name.slice(position, length);
      }

      return name;
    };

    beforeAll(() => {
      mockData = {
        logger: new Logger(LoggerLevel.DEBUG),
        addressesByName: new Map(),
        provider: mockProvider,
        config: {
          developerAbbreviation: 'TEST',
          minASCIICharacters: 5,
          maxASCIIHomoglyphs: 4,
          ethRegistrarControllerAddress: createAddress('0xAABBCCDDEEFF'),
        },
        isDevelopment: false,
        isInitialized: true,
      } as DataContainer;
      handleTransaction = provideHandleTransaction(mockData);
    });

    it('returns empty findings if there are no spoofed ENS names', async () => {
      mockData.config.minASCIICharacters = 5;

      const pairs = [
        ['wildcat', 'wildcat1'],
        ['admin', 'admiin'],
        ['12345678', '12345679'],
        ['testname', 'testname-'],
        ['monkey', 'monkeyüêç'],
        ['name / with separator', 'name | with separator'],
        ['', '    '],
      ];

      for (const pair of pairs) {
        registerName(pair[0], autoAddress());
        const findings = await handleTransaction(
          getENSRegisterTx(
            pair.slice(1).map((name) => ({
              name: name,
              account: autoAddress(),
            })),
          ),
        );
        expect(findings).toStrictEqual([]);
      }
    });

    it('returns empty findings if ENS name is short enough to be spoofed with ASCII homohlyphs', async () => {
      mockData.config.minASCIICharacters = 8;

      const legitName = 'wildcat';
      const legitAccount = autoAddress();
      const impersonatingName = 'w1ldcat';
      const impersonatingAccount = autoAddress();

      registerName(legitName, legitAccount);

      const findings = await handleTransaction(
        getENSRegisterTx([
          {
            name: impersonatingName,
            account: impersonatingAccount,
          },
        ]),
      );

      expect(findings).toStrictEqual([]);
    });

    it('returns a finding if ENS name was spoofed with ASCII homoglyphs', async () => {
      const glyphsBySymbol = {
        '0': ['o'],
        '1': ['l', 'i', '|'],
        b: ['d', 'lb'],
        c: ['e'],
        d: ['b'],
        e: ['c'],
        g: ['q'],
        h: ['lh'],
        i: ['1', 'l', '|'],
        k: ['lk', 'ik', 'lc'],
        l: ['1', 'i', '|'],
        m: ['n', 'nn', 'rn', 'rr'],
        n: ['m', 'r'],
        o: ['0'],
        q: ['g'],
        w: ['vv'],
      };

      for (const [symbol, glyphs] of Object.entries(glyphsBySymbol)) {
        const legitName = generateName([symbol]);
        const legitAccount = autoAddress();

        registerName(legitName, legitAccount);

        for (const glyph of glyphs) {
          const impersonatingName = generateName([glyph]);
          const impersonatingAccount = autoAddress();

          const findings = await handleTransaction(
            getENSRegisterTx([{ name: impersonatingName, account: impersonatingAccount }]),
          );

          expect(findings).toStrictEqual([
            createFinding({
              legitName,
              legitAccount,
              impersonatingName,
              impersonatingAccount,
              developerAbbreviation: mockData.config.developerAbbreviation,
            }),
          ]);
        }
      }

      // test multiple symbols simultaneously

      const legitName = generateName(['0', '1', 'k', 'w'], 1, 10);
      const legitAccount = autoAddress();

      const impersonatingName = generateName(['o', 'i', 'ik', 'vv'], 1, 10);
      const impersonatingAccount = autoAddress();

      const findings = await handleTransaction(
        getENSRegisterTx([{ name: impersonatingName, account: impersonatingAccount }]),
      );

      expect(findings).toStrictEqual([
        createFinding({
          legitName,
          legitAccount,
          impersonatingName,
          impersonatingAccount,
          developerAbbreviation: mockData.config.developerAbbreviation,
        }),
      ]);
    });

    it('returns a finding if ENS name was spoofed with unicode homoglyphs', async () => {
      // we should detect the use of unicode homoglyphs with any number of ASCII characters
      mockData.config.minASCIICharacters = 1;

      const glyphsBySymbol = {
        '2': ['∆ª'],
        '5': ['∆Ω'],
        a: ['√†', '√°', '√†', '√¢', '√£', '√§', '√•', '…ë', '·∫°', '«é', 'ƒÉ', '»ß', 'ƒÖ', '…ô'],
        b: [' ô', '…ì', '·∏É', '·∏Ö', '·∏á', '∆Ö'],
        c: ['∆à', 'ƒã', 'ƒá', '√ß', 'ƒç', 'ƒâ', '·¥Ñ'],
        d: ['…ó', 'ƒë', 'ƒè', '…ñ', '·∏ë', '·∏ã', '·∏ç', '·∏è', '·∏ì'],
        e: ['√©', '√®', '√™', '√´', 'ƒì', 'ƒï', 'ƒõ', 'ƒó', '·∫π', 'ƒô', '»©', '…á', '·∏õ'],
        f: ['∆í', '·∏ü'],
        g: ['…¢', '…°', 'ƒ°', 'ƒü', '«µ', 'ƒ£', 'ƒù', '«ß', '«•'],
        h: ['ƒ•', '»ü', 'ƒß', '…¶', '·∏ß', '·∏©', '‚±®', '·∏£', '·∏•', '·∏´', '·∫ñ'],
        i: ['√≠', '√¨', '√Ø', 'ƒ±', '…©', '«ê', 'ƒ≠', '·ªâ', '·ªã', '…®', '»ã', 'ƒ´', '…™'],
        j: [' ù', '«∞', '…â', 'ƒµ'],
        k: ['·∏≥', '·∏µ', '‚±™', 'ƒ∑', '·¥ã'],
        l: ['…´', '≈Ç'],
        m: ['·πÅ', '·πÉ', '·¥ç', '…±', '·∏ø'],
        n: ['≈Ñ', '·πÖ', '·πá', '·πâ', '√±', '≈Ü', '«π', '≈à', 'Íûë'],
        o: ['»Ø', '·ªç', '·ªè', '∆°', '√≥', '√∂', '·¥è'],
        p: ['∆ø', '∆•', '·πï', '·πó'],
        q: [' †'],
        r: [' Ä', '…º', '…Ω', '≈ï', '≈ó', '≈ô', '…ç', '…æ', '»ì', '»ë', '·πô', '·πõ', '·πü'],
        s: [' Ç', '≈õ', '·π£', '·π°', '»ô', '≈ù', '≈°', 'Íú±'],
        t: ['≈£', '≈ß', '·π´', '·π≠', '»õ', '∆´'],
        u: ['·¥ú', '«î', '≈≠', '√º', ' â', '√π', '√∫', '√ª', '≈©', '≈´', '≈≥', '∆∞', '≈Ø', '≈±', '»ï', '»ó', '·ª•'],
        v: ['·πø', '‚±±', '·∂å', '·πΩ', '‚±¥', '·¥†'],
        w: ['≈µ', '·∫Å', '·∫É', '·∫Ö', '‚±≥', '·∫á', '·∫â', '·∫ò', '·¥°'],
        x: ['·∫ã', '·∫ç'],
        y: [' è', '√Ω', '√ø', '≈∑', '∆¥', '»≥', '…è', '·ªø', '·∫è', '·ªµ'],
        z: [' ê', '≈º', '≈∫', '·¥¢', '∆∂', '·∫ì', '·∫ï', '‚±¨'],
      };

      for (const [symbol, glyphs] of Object.entries(glyphsBySymbol)) {
        const legitName = generateName([symbol]);
        const legitAccount = autoAddress();

        registerName(legitName, legitAccount);

        for (const glyph of glyphs) {
          const impersonatingName = generateName([glyph]);
          const impersonatingAccount = autoAddress();

          const findings = await handleTransaction(
            getENSRegisterTx([{ name: impersonatingName, account: impersonatingAccount }]),
          );

          expect(findings).toStrictEqual([
            createFinding({
              legitName,
              legitAccount,
              impersonatingName,
              impersonatingAccount,
              developerAbbreviation: mockData.config.developerAbbreviation,
            }),
          ]);
        }
      }

      // test multiple symbols simultaneously

      const legitName = generateName(['p', 'r', 'i', 'u'], 1, 10);
      const legitAccount = autoAddress();

      const impersonatingName = generateName(['·πó', '·πõ', '√¨', '·¥ú'], 1, 10);
      const impersonatingAccount = autoAddress();

      const findings = await handleTransaction(
        getENSRegisterTx([{ name: impersonatingName, account: impersonatingAccount }]),
      );

      expect(findings).toStrictEqual([
        createFinding({
          legitName,
          legitAccount,
          impersonatingName,
          impersonatingAccount,
          developerAbbreviation: mockData.config.developerAbbreviation,
        }),
      ]);
    });

    it('returns a finding if ENS name was spoofed with cyrillic homoglyphs', async () => {
      // we should detect the use of cyrillic homoglyphs with any number of ASCII characters
      mockData.config.minASCIICharacters = 1;

      const glyphsBySymbol = {
        a: '–∞',
        b: '—å',
        c: '—Å',
        d: '‘Å',
        e: '–µ',
        g: '‘ç',
        h: '“ª',
        i: '—ñ',
        j: '—ò',
        k: '–∫',
        l: '”è',
        m: '–º',
        o: '–æ',
        p: '—Ä',
        q: '‘õ',
        s: '—ï',
        t: '—Ç',
        v: '—µ',
        w: '‘ù',
        x: '—Ö',
        y: '—É',
      };

      for (const [symbol, glyph] of Object.entries(glyphsBySymbol)) {
        const legitName = generateName([symbol]);
        const legitAccount = autoAddress();

        registerName(legitName, legitAccount);

        const impersonatingName = generateName([glyph]);
        const impersonatingAccount = autoAddress();

        const findings = await handleTransaction(
          getENSRegisterTx([{ name: impersonatingName, account: impersonatingAccount }]),
        );

        expect(findings).toStrictEqual([
          createFinding({
            legitName,
            legitAccount,
            impersonatingName,
            impersonatingAccount,
            developerAbbreviation: mockData.config.developerAbbreviation,
          }),
        ]);
      }

      // test multiple symbols simultaneously

      const legitName = generateName(['a', 'c', 'k', 'o'], 1, 10);
      const legitAccount = autoAddress();

      const impersonatingName = generateName(['–∞', '—Å', '–∫', '–æ'], 1, 10);
      const impersonatingAccount = autoAddress();

      const findings = await handleTransaction(
        getENSRegisterTx([{ name: impersonatingName, account: impersonatingAccount }]),
      );

      expect(findings).toStrictEqual([
        createFinding({
          legitName,
          legitAccount,
          impersonatingName,
          impersonatingAccount,
          developerAbbreviation: mockData.config.developerAbbreviation,
        }),
      ]);
    });

    it('returns a finding if ENS name was spoofed with uppercase characters', async () => {
      const legitName = 'bitcoin';
      const legitAccount = autoAddress();

      const impersonators = [
        {
          name: 'Bitcoin',
          account: autoAddress(),
        },
        {
          name: 'bItcoIn',
          account: autoAddress(),
        },
        {
          name: 'bitcoiN',
          account: autoAddress(),
        },
      ];

      registerName(legitName, legitAccount);

      for (const impersonator of impersonators) {
        const findings = await handleTransaction(getENSRegisterTx([impersonator]));

        expect(findings).toStrictEqual([
          createFinding({
            legitName,
            legitAccount,
            impersonatingName: impersonator.name,
            impersonatingAccount: impersonator.account,
            developerAbbreviation: mockData.config.developerAbbreviation,
          }),
        ]);
      }
    });

    it('returns a finding if ENS name was spoofed with non-printable characters', async () => {
      // we should detect the use of non-printable homoglyphs with any number of ASCII characters
      mockData.config.minASCIICharacters = 1;

      // https://github.com/spencermountain/out-of-character/blob/main/data/characters.json
      const invisibleSymbols = [
        '\u000A',
        '\u000B',
        '\u000C',
        '\u000D',
        '\u00A0',
        '\u0085',
        '\u2028',
        '\u2029',
        '\u0009',
        '\u0020',
        '\u00AD',
        '\u034F',
        '\u061C',
        '\u070F',
        '\u115F',
        '\u1160',
        '\u1680',
        '\u17B4',
        '\u17B5',
        '\u180E',
        '\u2000',
        '\u2001',
        '\u2002',
        '\u2003',
        '\u2004',
        '\u2005',
        '\u2006',
        '\u2007',
        '\u2008',
        '\u2009',
        '\u200A',
        '\u200B',
        '\u200C',
        '\u200D',
        '\u200E',
        '\u200F',
        '\u202F',
        '\u205F',
        '\u2060',
        '\u2061',
        '\u2062',
        '\u2063',
        '\u2064',
        '\u206A',
        '\u206B',
        '\u206C',
        '\u206D',
        '\u206E',
        '\u206F',
        '\u3000',
        '\u2800',
        '\u3164',
        '\uFEFF',
        '\uFFA0',
        '\u110B1',
        '\u1BCA0',
        '\u1BCA1',
        '\u1BCA2',
        '\u1BCA3',
        '\u1D159',
        '\u1D173',
        '\u1D174',
        '\u1D175',
        '\u1D176',
        '\u1D177',
        '\u1D178',
        '\u1D179',
        '\u1D17A',
      ];

      const legitName = generateName([], 1);
      const legitAccount = autoAddress();

      registerName(legitName, legitAccount);

      for (const symbol of invisibleSymbols) {
        // insert invisible characters into specific positions
        const nameChars = Array.from(legitName);
        for (const position of [0, 2, legitName.length + 2, legitName.length + 3]) {
          nameChars.splice(position, 0, symbol);
        }

        const impersonatingName = nameChars.join('');
        const impersonatingAccount = autoAddress();

        const findings = await handleTransaction(
          getENSRegisterTx([
            {
              name: impersonatingName,
              account: impersonatingAccount,
            },
          ]),
        );

        expect(findings).toStrictEqual([
          createFinding({
            legitName,
            legitAccount,
            impersonatingName,
            impersonatingAccount,
            developerAbbreviation: mockData.config.developerAbbreviation,
          }),
        ]);
      }

      // test multiple symbols simultaneously

      const impersonatingName =
        '\u0020' + legitName.slice(0, 3) + '\u000A' + legitName.slice(3) + '\u2800' + '\u200C';
      const impersonatingAccount = autoAddress();

      const findings = await handleTransaction(
        getENSRegisterTx([{ name: impersonatingName, account: impersonatingAccount }]),
      );

      expect(findings).toStrictEqual([
        createFinding({
          legitName,
          legitAccount,
          impersonatingName,
          impersonatingAccount,
          developerAbbreviation: mockData.config.developerAbbreviation,
        }),
      ]);
    });

    it('returns a finding if ENS name was spoofed with multiple homoglyph techniques', async () => {
      const legitName = 'wildcat';
      const legitAccount = autoAddress();

      const impersonatingName =
        'W' /* capitalized */ +
        '1' /* similar looking ASCII */ +
        '”è' /* cyrillic */ +
        'd' +
        'ƒã' /* unicode */ +
        'at' +
        '\u00A0'; /* invisible symbol */
      const impersonatingAccount = autoAddress();

      const findings = await handleTransaction(
        getENSRegisterTx([{ name: impersonatingName, account: impersonatingAccount }]),
      );

      expect(findings).toStrictEqual([
        createFinding({
          legitName,
          legitAccount,
          impersonatingName,
          impersonatingAccount,
          developerAbbreviation: mockData.config.developerAbbreviation,
        }),
      ]);
    });

    it('returns multiple findings', async () => {
      const legitName1 = 'wildcat';
      const legitAccount1 = autoAddress();
      const legitName2 = 'legit';
      const legitAccount2 = autoAddress();

      const impersonatingName1 = 'Wildcat';
      const impersonatingAccount1 = autoAddress();
      const impersonatingName2 = 'w1ldcat';
      const impersonatingAccount2 = autoAddress();
      const impersonatingName3 = 'legit' + '\u000A';
      const impersonatingAccount3 = autoAddress();

      registerName(legitName1, legitAccount1);
      registerName(legitName2, legitAccount2);

      const findings = await handleTransaction(
        getENSRegisterTx([
          { name: impersonatingName1, account: impersonatingAccount1 },
          { name: impersonatingName2, account: impersonatingAccount2 },
          { name: impersonatingName3, account: impersonatingAccount3 },
        ]),
      );

      expect(findings).toStrictEqual([
        createFinding({
          legitName: legitName1,
          legitAccount: legitAccount1,
          impersonatingName: impersonatingName1,
          impersonatingAccount: impersonatingAccount1,
          developerAbbreviation: mockData.config.developerAbbreviation,
        }),
        createFinding({
          legitName: legitName1,
          legitAccount: legitAccount1,
          impersonatingName: impersonatingName2,
          impersonatingAccount: impersonatingAccount2,
          developerAbbreviation: mockData.config.developerAbbreviation,
        }),
        createFinding({
          legitName: legitName2,
          legitAccount: legitAccount2,
          impersonatingName: impersonatingName3,
          impersonatingAccount: impersonatingAccount3,
          developerAbbreviation: mockData.config.developerAbbreviation,
        }),
      ]);
    });
  });
});
